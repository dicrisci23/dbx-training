# This workflow creates automatic releases when code is merged to main branch
# It generates release notes automatically and creates semantic version tags
name: 'Automatic Release'

# Trigger on push to main branch (when PRs are merged)
on:
  push:
    branches:
      - main
      - master
    # Ignore changes to docs and workflows to avoid unnecessary releases
    paths-ignore:
      - '**.md'
      - '.github/**'
      - 'docs/**'
      - 'LICENSE'
      - '.gitignore'

# Ensure only one release workflow runs at a time
concurrency:
  group: release
  cancel-in-progress: false

permissions:
  contents: write       # needed to create releases and tags
  pull-requests: read   # needed to read PR information for release notes
  actions: read         # needed to access workflow/job metadata
  issues: read          # needed to include issue references in release notes

jobs:
  # Determine if we should create a release and what version
  check-release:
    name: 'Check if release is needed'
    runs-on: ubuntu-latest
    outputs:
      should-release: ${{ steps.check.outputs.should-release }}
      version-type: ${{ steps.check.outputs.version-type }}
      new-version: ${{ steps.version.outputs.new-version }}
      previous-version: ${{ steps.version.outputs.previous-version }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper release note generation

      # Check recent commits to determine release type
      - name: Check commit messages for release signals
        id: check
        run: |
          echo "üîç Analyzing recent commits for release signals..."
          
          # Get the last command run in the active terminal.
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            # Validate that the tag actually exists as a commit
            if git rev-parse --verify "$LAST_TAG" >/dev/null 2>&1; then
              COMMITS_SINCE_TAG=$(git rev-list ${LAST_TAG}..HEAD --oneline)
              echo "üìã Commits since last tag ($LAST_TAG):"
              echo "$COMMITS_SINCE_TAG"
            else
              echo "üìã Last tag found but not valid, treating as first release"
              LAST_TAG=""
              COMMITS_SINCE_TAG=$(git rev-list HEAD --oneline --max-count=50)
            fi
          else
            echo "üìã No previous tags found, this will be the first release"
            COMMITS_SINCE_TAG=$(git rev-list HEAD --oneline --max-count=50)
          fi
          
          # Analyze commit messages for semantic versioning hints
          if [ -n "$LAST_TAG" ] && git rev-parse --verify "$LAST_TAG" >/dev/null 2>&1; then
            COMMIT_MESSAGES=$(git log --format="%s" ${LAST_TAG}..HEAD 2>/dev/null)
          else
            COMMIT_MESSAGES=$(git log --format="%s" HEAD --max-count=50 2>/dev/null)
          fi
          
          echo "üìù Recent commit messages:"
          echo "$COMMIT_MESSAGES"
          
          # Check for breaking changes (major version)
          if echo "$COMMIT_MESSAGES" | grep -i -E "(breaking|major|\[breaking\]|\!:|BREAKING CHANGE)" > /dev/null; then
            echo "üö® Breaking changes detected - MAJOR release"
            echo "version-type=major" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
          # Check for new features (minor version)
          elif echo "$COMMIT_MESSAGES" | grep -i -E "(feat|feature|add|new|\[feat\])" > /dev/null; then
            echo "‚ú® New features detected - MINOR release"
            echo "version-type=minor" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
          # Check for bug fixes and other changes (patch version)
          elif echo "$COMMIT_MESSAGES" | grep -i -E "(fix|bug|patch|update|improve|refactor|\[fix\]|\[patch\])" > /dev/null; then
            echo "üêõ Bug fixes/improvements detected - PATCH release"
            echo "version-type=patch" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
          # Check if there are any substantial changes at all
          elif [ -n "$COMMITS_SINCE_TAG" ] && [ $(echo "$COMMITS_SINCE_TAG" | wc -l) -gt 0 ]; then
            echo "üì¶ Changes detected but no clear signals - defaulting to PATCH release"
            echo "version-type=patch" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
          else
            echo "‚è≠Ô∏è No significant changes detected - skipping release"
            echo "should-release=false" >> $GITHUB_OUTPUT
          fi

      # Calculate next version number
      - name: Calculate next version
        id: version
        if: steps.check.outputs.should-release == 'true'
        run: |
          echo "üî¢ Calculating next version number..."
          
          # Get latest tag or start with v1.0.0
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "üìå Latest tag: $LATEST_TAG"
          
          # Remove 'v' prefix if present
          CURRENT_VERSION=$(echo $LATEST_TAG | sed 's/^v//')
          
          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Default values if parsing fails
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}
          
          echo "üìä Current version: $MAJOR.$MINOR.$PATCH"
          
          # Increment based on version type
          VERSION_TYPE="${{ steps.check.outputs.version-type }}"
          case $VERSION_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
            *)
              echo "‚ùå Unknown version type: $VERSION_TYPE"
              exit 1
              ;;
          esac
          
          NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          
          echo "üÜï New version: $NEW_VERSION"
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "previous-version=$LATEST_TAG" >> $GITHUB_OUTPUT

  # Create the release
  create-release:
    name: 'Create Release'
    runs-on: ubuntu-latest
    needs: check-release
    if: needs.check-release.outputs.should-release == 'true'
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Generate release notes automatically
      - name: Generate Release Notes
        id: release-notes
        run: |
          echo "üìù Generating automatic release notes..."
          
          NEW_VERSION="${{ needs.check-release.outputs.new-version }}"
          PREVIOUS_VERSION="${{ needs.check-release.outputs.previous-version }}"
          VERSION_TYPE="${{ needs.check-release.outputs.version-type }}"
          
          # Create release notes file
          RELEASE_NOTES_FILE="release-notes-$NEW_VERSION.md"
          
          # Release header
          cat > $RELEASE_NOTES_FILE << EOF
          # Release $NEW_VERSION
          
          **Release Type:** $(echo $VERSION_TYPE | tr '[:lower:]' '[:upper:]') 
          **Release Date:** $(date '+%Y-%m-%d')
          **Previous Version:** $PREVIOUS_VERSION
          
          EOF
          
          # Get commits since last tag - handle first release case
          if [ "$PREVIOUS_VERSION" != "v0.0.0" ] && [ -n "$PREVIOUS_VERSION" ] && git rev-parse --verify "$PREVIOUS_VERSION" >/dev/null 2>&1; then
            echo "üìã Getting commits since $PREVIOUS_VERSION"
            COMMITS=$(git log --format="- %s (%h)" ${PREVIOUS_VERSION}..HEAD --no-merges)
            PR_MERGES=$(git log --format="- %s (%h)" ${PREVIOUS_VERSION}..HEAD --merges --grep="Merge pull request")
          else
            echo "üìã First release - including all commits"
            COMMITS=$(git log --format="- %s (%h)" HEAD --no-merges --max-count=50)
            PR_MERGES=$(git log --format="- %s (%h)" HEAD --merges --grep="Merge pull request" --max-count=20)
          fi
          
          # Categorize changes
          echo "## üöÄ What's New" >> $RELEASE_NOTES_FILE
          echo "" >> $RELEASE_NOTES_FILE
          
          # Breaking changes
          if echo "$COMMITS" | grep -i -E "breaking|major|\[breaking\]|\!:" > /dev/null; then
            echo "### ‚ö†Ô∏è Breaking Changes" >> $RELEASE_NOTES_FILE
            echo "$COMMITS" | grep -i -E "breaking|major|\[breaking\]|\!:" >> $RELEASE_NOTES_FILE
            echo "" >> $RELEASE_NOTES_FILE
          fi
          
          # New features
          if echo "$COMMITS" | grep -i -E "feat|feature|add|new|\[feat\]" > /dev/null; then
            echo "### ‚ú® New Features" >> $RELEASE_NOTES_FILE
            echo "$COMMITS" | grep -i -E "feat|feature|add|new|\[feat\]" >> $RELEASE_NOTES_FILE
            echo "" >> $RELEASE_NOTES_FILE
          fi
          
          # Bug fixes
          if echo "$COMMITS" | grep -i -E "fix|bug|patch|\[fix\]|\[patch\]" > /dev/null; then
            echo "### üêõ Bug Fixes" >> $RELEASE_NOTES_FILE
            echo "$COMMITS" | grep -i -E "fix|bug|patch|\[fix\]|\[patch\]" >> $RELEASE_NOTES_FILE
            echo "" >> $RELEASE_NOTES_FILE
          fi
          
          # Improvements and other changes
          OTHER_COMMITS=$(echo "$COMMITS" | grep -v -i -E "breaking|major|feat|feature|add|new|fix|bug|patch|\[breaking\]|\[feat\]|\[fix\]|\[patch\]|\!:")
          if [ -n "$OTHER_COMMITS" ]; then
            echo "### üîß Improvements & Other Changes" >> $RELEASE_NOTES_FILE
            echo "$OTHER_COMMITS" >> $RELEASE_NOTES_FILE
            echo "" >> $RELEASE_NOTES_FILE
          fi
          
          # Merged Pull Requests
          if [ -n "$PR_MERGES" ]; then
            echo "### üîÑ Merged Pull Requests" >> $RELEASE_NOTES_FILE
            echo "$PR_MERGES" >> $RELEASE_NOTES_FILE
            echo "" >> $RELEASE_NOTES_FILE
          fi
          
          # Technical details
          echo "## üìã Technical Details" >> $RELEASE_NOTES_FILE
          echo "" >> $RELEASE_NOTES_FILE
          echo "- **Commit SHA:** \`${{ github.sha }}\`" >> $RELEASE_NOTES_FILE
          echo "- **Build Number:** \`${{ github.run_number }}\`" >> $RELEASE_NOTES_FILE
          echo "- **Workflow:** [View Build Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $RELEASE_NOTES_FILE
          
          # Count changes
          COMMIT_COUNT=$(echo "$COMMITS" | wc -l)
          if [ $COMMIT_COUNT -gt 0 ]; then
            echo "- **Changes:** $COMMIT_COUNT commit(s)" >> $RELEASE_NOTES_FILE
          fi
          
          # Add contributors info
          if [ -n "$PREVIOUS_VERSION" ] && [ "$PREVIOUS_VERSION" != "v0.0.0" ] && git rev-parse --verify "$PREVIOUS_VERSION" >/dev/null 2>&1; then
            CONTRIBUTORS=$(git log ${PREVIOUS_VERSION}..HEAD --format="%aN" | sort -u | head -10)
          else
            CONTRIBUTORS=$(git log HEAD --format="%aN" --max-count=50 | sort -u | head -10)
          fi
          if [ -n "$CONTRIBUTORS" ]; then
            echo "" >> $RELEASE_NOTES_FILE
            echo "## üë• Contributors" >> $RELEASE_NOTES_FILE
            echo "" >> $RELEASE_NOTES_FILE
            echo "Thanks to all contributors who made this release possible:" >> $RELEASE_NOTES_FILE
            echo "" >> $RELEASE_NOTES_FILE
            echo "$CONTRIBUTORS" | while read contributor; do
              echo "- @$contributor" >> $RELEASE_NOTES_FILE
            done
          fi
          
          # Repository-specific notes for Databricks project
          echo "" >> $RELEASE_NOTES_FILE
          echo "## üèóÔ∏è Databricks Bundle Information" >> $RELEASE_NOTES_FILE
          echo "" >> $RELEASE_NOTES_FILE
          
          # Find and list all bundles
          BUNDLE_DIRS=$(find . -name "databricks.yml" -type f | sed 's|/databricks.yml||' | sed 's|^\./||' | sort)
          if [ -n "$BUNDLE_DIRS" ]; then
            echo "This release includes the following Databricks bundles:" >> $RELEASE_NOTES_FILE
            echo "" >> $RELEASE_NOTES_FILE
            echo "$BUNDLE_DIRS" | while read bundle_dir; do
              BUNDLE_NAME=$(basename "$bundle_dir")
              echo "- **$BUNDLE_NAME** (\`$bundle_dir\`)" >> $RELEASE_NOTES_FILE
            done
            echo "" >> $RELEASE_NOTES_FILE
            echo "All bundles have been validated and are ready for deployment." >> $RELEASE_NOTES_FILE
          fi
          
          # Usage instructions
          echo "" >> $RELEASE_NOTES_FILE
          echo "## üì¶ Installation & Usage" >> $RELEASE_NOTES_FILE
          echo "" >> $RELEASE_NOTES_FILE
          echo "To use this release:" >> $RELEASE_NOTES_FILE
          echo "" >> $RELEASE_NOTES_FILE
          echo "1. **Download the source code** from the assets below" >> $RELEASE_NOTES_FILE
          echo "2. **Clone or update your local repository:**" >> $RELEASE_NOTES_FILE
          echo "   \`\`\`bash" >> $RELEASE_NOTES_FILE
          echo "   git checkout $NEW_VERSION" >> $RELEASE_NOTES_FILE
          echo "   \`\`\`" >> $RELEASE_NOTES_FILE
          echo "3. **Deploy Databricks bundles** using the Databricks CLI" >> $RELEASE_NOTES_FILE
          echo "" >> $RELEASE_NOTES_FILE
          echo "---" >> $RELEASE_NOTES_FILE
          echo "" >> $RELEASE_NOTES_FILE
          echo "_This release was automatically generated by GitHub Actions._" >> $RELEASE_NOTES_FILE
          
          echo "üìÑ Release notes generated:"
          echo "----------------------------------------"
          cat $RELEASE_NOTES_FILE
          echo "----------------------------------------"
          
          # Set output for next step
          echo "release-notes-file=$RELEASE_NOTES_FILE" >> $GITHUB_OUTPUT

      # Create the GitHub release
      - name: Create GitHub Release
        uses: actions/create-release@v1
        id: create-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.check-release.outputs.new-version }}
          release_name: 'Release ${{ needs.check-release.outputs.new-version }}'
          body_path: ${{ steps.release-notes.outputs.release-notes-file }}
          draft: false
          prerelease: false

      # Upload source code as release assets
      - name: Create and upload release assets
        run: |
          echo "üì¶ Creating release assets..."
          
          NEW_VERSION="${{ needs.check-release.outputs.new-version }}"
          
          # Create dist directory for assets
          mkdir -p dist
          
          # Create a clean source archive (excluding git and CI files)
          # Use --warning=no-file-changed to handle files modified during archiving
          tar --warning=no-file-changed \
              --exclude='.git*' \
              --exclude='.github' \
              --exclude='node_modules' \
              --exclude='*.tar.gz' \
              --exclude='*.zip' \
              --exclude='dist' \
              -czf "dist/databricks-bundles-$NEW_VERSION-source.tar.gz" .
          
          # Create a zip archive as well
          zip -r "dist/databricks-bundles-$NEW_VERSION-source.zip" . \
              -x ".git/*" ".github/*" "node_modules/*" "*.tar.gz" "*.zip" "dist/*"
          
          echo "‚úÖ Release assets created:"
          ls -la dist/
          
          # Upload assets using GitHub CLI
          gh release upload "$NEW_VERSION" \
            "dist/databricks-bundles-$NEW_VERSION-source.tar.gz" \
            "dist/databricks-bundles-$NEW_VERSION-source.zip" \
            --clobber
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Post-release validation (optional quality check)
      - name: Post-release bundle status check
        run: |
          echo "ÔøΩ Post-release information about Databricks bundles..."
          
          # Find all databricks.yml files
          BUNDLE_DIRS=$(find . -name "databricks.yml" -type f | sed 's|/databricks.yml||' | sed 's|^\./||' | sort)
          
          if [ -n "$BUNDLE_DIRS" ]; then
            echo "üì¶ This release includes the following Databricks bundles:"
            
            for bundle_dir in $BUNDLE_DIRS; do
              BUNDLE_NAME=$(basename "$bundle_dir")
              echo "   ‚úÖ $BUNDLE_NAME ($bundle_dir)"
            done
            
            echo ""
            echo "üí° Bundle validation was performed during PR review."
            echo "   All bundles in this release have been pre-validated."
          else
            echo "üìù No Databricks bundles found in release"
          fi
        continue-on-error: true

      # Post-release notification
      - name: Release notification
        run: |
          echo "üéâ Release ${{ needs.check-release.outputs.new-version }} has been successfully created!"
          echo ""
          echo "üìã Release Summary:"
          echo "   - Version: ${{ needs.check-release.outputs.new-version }}"
          echo "   - Type: ${{ needs.check-release.outputs.version-type }}"
          echo "   - Previous: ${{ needs.check-release.outputs.previous-version }}"
          echo "   - Commit: ${{ github.sha }}"
          echo ""
          echo "üîó Release URL: ${{ steps.create-release.outputs.html_url }}"
          echo ""
          echo "‚ú® The release includes automatic release notes and source code assets."